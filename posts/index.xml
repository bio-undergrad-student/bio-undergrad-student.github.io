<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Tutorials on Image Analysis Algorithms</title>
    <link>/posts/</link>
    <description>Tutorials on Image Analysis Algorithms (Posts)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    

    
    
    <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Algorithms Primer Part 1 :abacus:</title>
      <link>/posts/algorithms1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/algorithms1/</guid>
      <description>&lt;p&gt;In this tutorial we will go over some basic algorithms concepts along with some examples and exercises.&lt;/p&gt;
&lt;h2 id=&#34;what-are-algorithms&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#what-are-algorithms&#34;&gt;
        #
    &lt;/a&gt;
    What are algorithms?
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;An algorithm is essentially a set of instructions. Think about writing a bulleted list of everything you’d want a robot to do in sequential order. Take a look at the following example where we come up with a simple algorithm to retrieve a strawberry from a refrigerator.&lt;/p&gt;
&lt;p&gt;Move forward 3 steps → Move left 2 steps → Raise arm → Grab refrigerator door → Open refrigerator → Find strawberry → Grab strawberry → Put strawberry in basket → Close refrigerator door → Turn around → Move forward 2 steps → Move right 3 steps → Drop basket on target&lt;/p&gt;
&lt;p&gt;This is basically just a sequence of steps that the robot must follow, this is a very simple example of an algorithm. In practice we would have to translate each step into a code version, but that is secondary to designing algorithms.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/robot.jpg&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;basic-coding-refresher&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#basic-coding-refresher&#34;&gt;
        ##
    &lt;/a&gt;
    Basic Coding Refresher
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;Knowing basic coding operations is crucial in developing algorithms. The two main control structures we are concerned with are the if-else statement and for loop. These are the most frequently used in writing algorithms and it is important to understand exactly how they work.&lt;/p&gt;
&lt;p&gt;In the example of a real strawberry retrieving robot we have to specify exactly what we want from it using a programming language. Below is an example of what an instruction might look like in Python.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if is_in_refrigerator(strawberry) == true
    Robot.retrieve_item(strawberry)
else
    Robot.return()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if we wanted to use a for loop to retrieve multiple strawberries then we could use the following instruction &amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in range(10)
    if is_in_refrigerator(strawberry) == true
        Robot.retrieve_item(strawberry)
    else
        Robot.return()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;what-makes-a-good-algorithm&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#what-makes-a-good-algorithm&#34;&gt;
        ##
    &lt;/a&gt;
    What makes a good algorithm?
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;Whether an algorithm is considered good depends on the many qualities of that algorithm. Two of the most important qualities of an algorithm are space and time.&lt;/p&gt;
&lt;p&gt;Now what does space and time mean in the context of something running on a computer? Space refers to the amount of information that an algorithm saves during runtime. An example of space would be if we were required to store location information in our strawberry retrieval algorithm in order to backtrack and get back to our starting point. For systems such as robots that run on tight memory limitations, being mindful of memory usage is very important.&lt;/p&gt;
&lt;p&gt;Time is often thought to be the most important factor when designing an algorithm. Here time refers not to the literal wall clock time your algorithm runs in but rather the asymptotic complexity. The best way to think of time complexity is to think of your algorithm as a function of the input size. So ask yourself &amp;ldquo;as my input size increases how much additional work do I have to do?&amp;rdquo; As an example lets think about the time complexity of the code below using a for loop&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = len(input)
for i in range(n)
     print(&amp;quot;Hello World!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we have a for loop that runs in time proportional to the size of the input. In this case we say that the algorithm runs in $O(n)$ or &amp;ldquo;big O of n time&amp;rdquo;. This means the algorithm runtime grows in a linear fashion with respect to the input size much like the function $f(x) = x$. Below is a visual of the different common time complexities you may encounter when developing algorithms.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bigo.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;basics&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#basics&#34;&gt;
        #
    &lt;/a&gt;
    Basics
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;Most of the algorithms we first learn about in computer science courses are very basic, we are tasked with completing tasks such as ordering a list of numbers or finding the maximum element in that list. In this section of the algorithms primer you will learn a bit about these two tasks in an interactive way. The two tasks are formally known as searching and sorting tasks and by the end of this section you will implement your own list searching and sorting algorithms.&lt;/p&gt;
&lt;h3 id=&#34;data-structures&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#data-structures&#34;&gt;
        ##
    &lt;/a&gt;
    Data Structures
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;Before starting on algorithm development, it is important to be aware of various data structures. In this tutorial we are only concerned with the list or array, but there exists a wide variety of data structures each of which have their purpose and can help algorithms run faster. So lets learn a little more about our friend the list/array, as with most data structures we associate a time complexity to the operations we can perform on the structure. Here we have three distinct tasks i.e. insertion, deletion, and query.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Insertion&lt;/strong&gt; of an element into a list in $O(1)$ or &amp;ldquo;constant&amp;rdquo; time because we simply add it to the end of the list effortlessly.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deletion&lt;/strong&gt; of an element in a list can get a little complicated. If the element we want to delete just happens to be the last element in the list then we can achieve a deletion in $O(1)$. However, suppose the element we want to delete just happens to be the first in the list, now we&amp;rsquo;d have to delete the first element then shift the remaining elements forward by one. Here we now have a $O(n)$ operation since we are required to work with each element at one time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Query&lt;/strong&gt; or searching of a particular element in a list is similar to the example of deletion. For querying we have to search through our various elements and check for a match, this mean manually checking each and every element at least once. So the time complexity of querying an element in a list is $O(n)$. Later in this tutorial you will have the chance to implement an algorithm to perform this query operation.&lt;/p&gt;
&lt;h3 id=&#34;searchingquerying-tasks&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#searchingquerying-tasks&#34;&gt;
        ##
    &lt;/a&gt;
    Searching/Querying Tasks
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;A searching task is exactly what it sounds like, generally our goal is to search for a particular element within a data structure which is what holds our data. In this part of the tutorial our main objective will be to find a particular number within a list. More formally this problem is defined as searching for a particular integer value within an array. Take the list below as an example&amp;hellip;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/array.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;It is simple enough for us to determine if the number 5 is in the list, we can just look at it, for the computer it is a bit more complicated than that, we have to explicitly tell it how to know if a number is present. This is something we have to get used to.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1&lt;/strong&gt; What is the simplest way to have the computer tell us if a known number is present in a list?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We have an array named myList, and we can query the fourth element in the list as follows&amp;hellip;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myNumber = myList[3]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 2&lt;/strong&gt; Write some code to tell us if the 6th element in the list is equal to 3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;How can we apply a conditional statement to all elements in an array of unknown length? Regardless of what the size of an array is at runtime we can retrieve that number using the length function i.e. &lt;code&gt;len(myList)&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 3&lt;/strong&gt; Write some code to check all elements of the list to see if they are equal to 7.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That’s cool, but now imagine that we are given a stream of queries and we don’t know what the numbers are, how can we check if all of these numbers are present in our array? Suppose we have two arrays now, we have myList and we have a new array named queries. This is a list containing random numbers, our goal is to for each number in queries, check if it is present in myList.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 4&lt;/strong&gt; Now lets generalize, write an algorithm to search the myList array for all of the numbers in the queries array.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Congratulations, you just wrote an algorithm to query lists of integers!&lt;/p&gt;
&lt;h3 id=&#34;sorting-tasks&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#sorting-tasks&#34;&gt;
        ##
    &lt;/a&gt;
    Sorting Tasks
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;Now lets try a different, and more challenging, example, this time we want to take a list of numbers and sort them in increasing order. To write an algorithm for this problem we will take the same approach as we did for searching and try to solve simpler instances of the problem and then generalize.&lt;/p&gt;
&lt;p&gt;Lets start with an example of a list of size 2. What is the simplest way to sort the list below of size 2? Don’t think about the code for now just think about what the flowchart would look like.&lt;/p&gt;
&lt;p&gt;Assume you have access to a swap function that work as in the example below…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;myList = [1,2,3,4,5]

swap(myList[0],myList[1])

print(myList) # Output: [2,1,3,4,5]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 5&lt;/strong&gt; Implement some code to sort a list of numbers of size 2.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if myList[0] &amp;gt; myList[1]
        swap(myList[0], myList[1])
        return myList
else
        return myList
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code essentially asks one fundamental question i.e. is the first element smaller than the second? Now we are going to make a intellectual jump in order to generalize this problem, think about the following idea to sort a list of arbitrary size.&lt;/p&gt;
&lt;p&gt;What process would you use in order to solve this problem on a list of size 3 like the one below?&lt;/p&gt;
&lt;p&gt;What if we ask this same fundamental question repeatedly on sublists of a larger list. Take the list below as an example, first we will ask the same question from earlier “is the first element smaller than all subsequent numbers” the only difference is that we are now talking about all the numbers that follow. Next we will ask the same question but starting at the second index, ignoring all prior elements. We will repeat this process until we are left with only the last two elements, before we know it our list will be in increasing order.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 6&lt;/strong&gt; Write some code that will sort an array of integers using the idea above.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for i in range(len(myList))
    for j in range(i, len(myList))
        if(myList[j] &amp;lt; myList[i])
            swap(myList[i], myList[j])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Remark 1&lt;/strong&gt; Can we prove that this will always work? In algorithms we must prove that an algorithm will return the correct output and run under specific time bounds. This is beyond the scope of this tutorial but I will provide an example below for those who are interested.&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt; This proof will be pretty informal but for the purpose of this tutorial it really doesn&amp;rsquo;t matter. Selection sort works because, in each step, you find the smallest thing left and put it where it belongs. By the time you’ve gone through all the steps, everything is in the right place.&lt;/p&gt;
&lt;p&gt;Think of organizing a deck of cards: you look for the smallest card, put it at the front, then look for the next smallest card, and so on. Since you&amp;rsquo;re always finding the smallest and putting it where it should go, by the end, everything is perfectly sorted!&lt;/p&gt;
&lt;p&gt;In all algorithms courses and in research we always look for two fundamental pieces when an algorithm is presented, a proof of its time complexity and a proof of correctness.&lt;/p&gt;
&lt;h3 id=&#34;on-generalization&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#on-generalization&#34;&gt;
        ##
    &lt;/a&gt;
    On generalization
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;Notice in the examples above, in searching and sorting we were able to take a simple task such as searching for the number 15 or determining the order of two integers and then generalize to arbitrary sets of data. Ultimately this is exactly what we do in order to solve the hardest problems in computer science. Think back to the robot problem from the beginning of this tutorial, we wanted to address the task of retrieving a strawberry from a refrigerator. Now imagine we wanted to generalize this algorithm to work on arbitrary item, not necessarily a strawberry and also imagine we wanted to generalize the location of the item. What you are now thinking would be an example of a more sophisticated artificial intelligence algorithm. In many cases we can generalize a problem enough and reframe it to solve a seemingly unrelated problem. For example what if instead of a strawberry in a kitchen setting we were in a torn down town after a natural disaster and the objective is to find survivors. This is a much more complicated task as the size of the space we are searching has become exponentially larger and the stakes are higher as we are searching for human life.&lt;/p&gt;
&lt;h2 id=&#34;conclusions-and-additional-resources&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#conclusions-and-additional-resources&#34;&gt;
        #
    &lt;/a&gt;
    Conclusions and additional resources
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;This concludes the first part of this algorithms primer tutorial, in the next tutorial you will learn more about general algorithm development frameworks that can be useful during your journey. Below I have also attached an amazing Computerphile video covering sorting algorithms and time complexity topics, I hope you enjoy! See you next time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Readings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.math.umd.edu/~immortal/CMSC351/notes/algorithmtimecomplexity.pdf&#34;&gt;Time Complexity Notes: Justin Wyss-Gallifent&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;Videos&lt;/strong&gt;&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/kgBjXUE_Nwc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    
    <item>
      <title>Algorithms Primer Part 2 :gear:</title>
      <link>/posts/algorithms2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/algorithms2/</guid>
      <description>&lt;p&gt;In this tutorial we will go over some more general frameworks that are used in the algorithm development process, along the way we will cover some examples and exercises.&lt;/p&gt;
&lt;h2 id=&#34;general-frameworks&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#general-frameworks&#34;&gt;
        #
    &lt;/a&gt;
    General Frameworks
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;It is often the case that beginners struggle with algorithms puzzles/problems such as those found on popular websites like LeetCode. The struggle primarily comes from a lack of a developed algorithms toolbox, the truth is that inventing a complicated algorithm just to solve a puzzle is not ideal. As we expand our knowledge of algorithmic techniques, data structures, and types of problems we find that some of these puzzles are trivial once you know the technique it is testing. Therefore your goal should be to learn as many techniques as possible to have the easiest time solving an algorithms problem.  In this tutorial we will cover two of the most popular techniques we see in algorithms development along with some examples and exercises. The two techniques being covered are divide and conquer and greedy, these can be often be applied to a wide range of problems regardless of domain.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Like all tutorials we will start with an example that incorporates these techniques. For the sake of this example suppose you are a working as part of a team of marmots whose diets are made up entirely of strawberries, they are also having a hard time working out the logistics of their food supply. This means that they are distributing strawberries to marmots at random, the problem with this approach is that small marmots are getting large strawberries (surplus) and large marmots are getting small strawberries (shortage). Thus, small marmots are contributing to a large amount of food waste and large marmots are going hungry, how can we use algorithms to solve this problem quickly as the marmots are very hungry?&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;http://localhost:1313/images/marmot.jpg&#34;
         alt=&#34;Example Image&#34; width=&#34;300px&#34;/&gt;
&lt;/figure&gt;

&lt;h3 id=&#34;divide-and-conquer&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#divide-and-conquer&#34;&gt;
        ##
    &lt;/a&gt;
    Divide and Conquer
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;Divide and conquer is a problem solving approach/framework which is a bit self explanatory. The technique works by splitting our input in smaller chunks, solving the smaller instances of the problem and then combine the results to solve the full problem. Now this approach cannot be applied to every problem, there are some limitations such as independence that we must be cautious of. Independence in this context refers to the idea that each one of our sub-problems, after splitting the input data, has no relation at all to the other sub-problems. This may become a little more clear once we go over the following example for sorting a list of integers. Suppose we are given the list below…&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/lilarray.jpg&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;p&gt;We want to sort this list under a time constraint but the size of the input array is far too large to be done using our sorting algorithm we learned in part 1, how do we address this problem? Let’s apply the divide and conquer problem solving approach to this!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1&lt;/strong&gt; Come up with three ideas of how we can split our input array in order to solve it more efficiently.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Great! Now the splitting of the array we are interested in is depicted below, here we do the splitting in half each time until we can’t split any further.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/dand1.jpg&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;p&gt;At this point we have a bunch of arrays of size 1 that are each in sorted order, why? Any list of one element is automatically in sorted order because there is only one element. Now how will this help us sort the entire list, we haven’t done any type of sorting so far? The trick comes in when we combine the sub-lists, we will sort them as we reconstruct a list of the original size. Take a look at the example below which completes one step of this reconstruction&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/dand2.jpg&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;p&gt;Here we take all of our lists of size 1 and construct $\frac{n}{2}$ lists of size 2 which are in sorted order. The sorting happens when we insert our elements into the list of size 2, the smallest element comes first and then the larger element. The algorithm will continue this procedure until we end up with a single list of size $n$, we call this algorithm Merge Sort. The algorithm makes use of a recursive function, meaning a function that calls itself over and over until some base case is reached, in this case we continue calling the &lt;code&gt;MERGE-SORT&lt;/code&gt; function as long as our lists have size greater than 1. Below is some code for the Merge Sort algorithm and the complete reconstruction of the list.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MERGE-SORT(array, left, right):
    if left &amp;lt; right:
        mid = (left + right) / 2

        # Recursively sort the two halves
        MERGE-SORT(array, left, mid)
        MERGE-SORT(array, mid + 1, right)

        # Merge the sorted halves
        MERGE(array, left, mid, right)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/dand3.jpg&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;p&gt;By using the divide and conquer approach we have now solved the sorting problem much faster than we could before, lets analyze to confirm.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Splitting Operation:&lt;/strong&gt; The big question is how do we represent this splitting and combining operation, clearly this doesn’t touch each element once so it’s not $O(n)$ nor is it doing constant $O(1)$ work, it’s something in between. We call this behavior $O(log(n))$, why? First we must understand what it is that the log function does, think about the following equation&amp;hellip;&lt;/p&gt;
&lt;p&gt;$$log_2(n) = c \iff 2^c =n$$&lt;/p&gt;
&lt;p&gt;When we take the log base 2 of some number what we get in return is the exact exponent of a base 2 exponential required to get of that “some number”. It takes a while to grasp but another way to think of it in terms of a list of size n, the log base 2 of n is equal to the number of times we have to split this list and it’s sub-lists in two before we get lists of size 1. This is the exact operation we are doing in Merge Sort, hence the reason why this splitting operation runs in $O(log(n))$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Merging Operation:&lt;/strong&gt; Now you might be asking if the splitting operation is $O(log(n))$ then combining is also $O(log(n))$ right? So why is the total time complexity of Merge Sort $O(n log(n))$? This is because the combining operation is not $O(log(n))$, lets really think about what is happening here, when we merge two lists we have to ask the question “which of these elements is the smallest?” And we ask this same question for all other sub-lists, in the worst case scenario we’d have to look through all $n$ of our elements one time just to make sure we have the smallest element each time. Furthermore, we are doing these checks totaling to $n$ comparison at each step of the combination process so that is $log(n)$ steps times $n$ checks $= nlog(n) \in O(n log(n))$. This completes the time analysis of Merge Sort.&lt;/p&gt;
&lt;p&gt;So as we have seen, divide and conquer approach can be very useful in cases such as sorting where sub problems are completely independent of each other. Next we will take a look at another approach which we will use alongside divide and conquer in order to solve the marmot-strawberry crisis.&lt;/p&gt;
&lt;h3 id=&#34;greedy-algorithms&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#greedy-algorithms&#34;&gt;
        ##
    &lt;/a&gt;
    Greedy Algorithms
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;The greedy approach to algorithm development is where we make a greedy decision in order to accomplish some task. In this context greedy refers to always taking as much as possible of some quantity. As an example we will go through the well known coin change problem. This is a problem where we are given a set of coin denominations (e.g. 1 cent, 5 cent, 10 cent) and we are asked what is the minimum number of coins required to make a certain amount of change. For example, 35 cents change can be made from 3x10 cent coins and 1x5 cent coin. In this case the greedy approach can be used to find the minimum number of coins required to make change for 35 cents. We simply take as many 10 cent coins as possible followed up by as many 5 cent coins as possible, this gives us 35 cents using 4 coins, any other combination would use more coins. As we can see we make a greedy decision at every step, always take as much as we can.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/coins.jpg&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now the problem with the greedy approach is that it doesn’t always work&amp;hellip;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 2&lt;/strong&gt; Can you find a counterexample for the greedy algorithm for the coin change problem?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Possible Solution&lt;/strong&gt; $denominations = {1,2,4,5}$ make change for 8 cents $5+1+1+1$ vs $4+4$&lt;/p&gt;
&lt;p&gt;Here the problem is that it is more efficient to make change using the 4 cent coins as opposed to using the 5 cent coin.&lt;/p&gt;
&lt;p&gt;Below I provide some example code for the greedy coin change problem&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GREEDY-COIN-CHANGE(coins, amount):
    #coins is array of coin denominations
    
    sort(coins) # in decreasing order

    result = 0

    # Iterate over each coin
    for coin in coins:
        if amount == 0:
            break
        
        # Use as many of this coin as possible
        count = amount / coin
        result = result + count

        # Reduce the remaining amount
        amount = amount - count * coin

    # If amount is not 0, the greedy approach may not work for this set of coins
    
    if amount &amp;gt; 0:
        return -1  # Indicates it&#39;s not possible to make the exact amount

    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the greedy approach is a very general framework, it can be applied in many different settings so we always have to keep an eye out. Next we will get a chance to apply this framework alongside the greedy approach to solve the problem from the introduction.&lt;/p&gt;
&lt;h3 id=&#34;addressing-food-insecurity-in-marmot-communities&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#addressing-food-insecurity-in-marmot-communities&#34;&gt;
        ##
    &lt;/a&gt;
    Addressing food insecurity in marmot communities
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;Now that we are equipped with more algorithmic tools to solve problems we are ready to solve the marmot-strawberry problem. Recall the problem statement; given that the community of marmots consists of n members each with an associated weight and we want to distribute n strawberries each with an associated size, find the best marmot-strawberry matching. Target time complexity: $O(nlog(n))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 3&lt;/strong&gt; Think about a potential solution to this problem, think about the algorithms and techniques we have learned so far in this chapter.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hint&lt;/strong&gt; Remember our goal here is to match big strawberries with big marmots and small strawberries with small marmots. Which tool can help us order objects?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 4&lt;/strong&gt; Given the two ordered lists of marmots and strawberries, how can we optimally choose marmot-strawberry assignments?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The idea here is to create arrays with the weights and sizes of both the marmots and the strawberries and then sort them in descending order. Since we know that the number of marmots and strawberries are the same then we know each marmot will get exactly one strawberry. Thus we can simply assign strawberries to marmots greedily, let the largest marmot take the largest strawberry then remove the pair from the list, continue this procedure until the lists are empty. This gives us a very simply greedy strawberry allocation algorithm, we can make things a little harder by allowing there to be more strawberries than marmots and thinking about how we would distribute the strawberries then.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 5&lt;/strong&gt; Implement an algorithm to solve the marmot-strawberry problem&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;conclusions&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#conclusions&#34;&gt;
        ##
    &lt;/a&gt;
    Conclusions
&lt;/div&gt;
&lt;/h3&gt;
&lt;p&gt;In future tutorials you will have the opportunity to develop your algorithmic thinking skills through applications in the biological sciences. Specifically we will be dealing with imaging data. There are countless procedures/assays that produce images, learning how to write the programs that analyze this type of data is crucial in modern lab settings. Below I have provided some additional readings on greedy algorithms and a video for divide and conquer. See you next time!&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;Readings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.math.umd.edu/~immortal/CMSC351/notes/mergesort.pdf&#34;&gt;Merge Sort: Justin Wyss-Gallifent&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.math.umd.edu/~immortal/CMSC351/notes/coinchanging.pdf&#34;&gt;Coin Change: Justin Wyss-Gallifent&lt;/a&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;Videos&lt;/strong&gt;&lt;/p&gt;

&lt;div style=&#34;position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://www.youtube.com/embed/ib4BHvr5-Ao&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;&#34; allowfullscreen title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    
    <item>
      <title>Analyzing Images With Fiji :desert_island:</title>
      <link>/posts/fiji/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/fiji/</guid>
      <description>&lt;p&gt;In this tutorial we will go over the basic analysis functionalities of the image analysis software Fiji.&lt;/p&gt;
&lt;p&gt;This the following couple of posts will be a series of tutorials on existing software for analyzing cellular imaging data. We will provide an essential quick start guide and encourage everyone to spend time messing around with these tools and some provided datasets to familiarize themselves with them. There will be 3/4 tutorials for this series where we will cover software for image analysis for small and large scale experiments, after we will dive into more experimental deep learning methods and introduction to cellular imaging data integration and batch correction.&lt;/p&gt;
&lt;h2 id=&#34;background&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#background&#34;&gt;
        #
    &lt;/a&gt;
    Background
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/island.jpg&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;p&gt;Did you know that the soft coral capital of the world, Fiji, is made 90% of water and has over 300 tropical islands! Unfortunately we will not be doing image analysis on the islands of Fiji. In this tutorial we will go over the image processing software Fiji. “Fiji is just ImageJ” is an open-source image processing software and extension of the original ImageJ developed at the National Institutes of Health (NIH). Fiji is used extensively in image analysis for microscopy images in 2D and 3D and is used in labs across the world to analyze phenotypic changes in cells at scale. Today you will have the opportunity to install this software on your computer and run through some basic analyses using some of the preset datasets within Fiji. Additionally, we will provide a mini-project in the next post which will help you familiarize yourself more with the ImageJ interface and identify potential applications in a field of your interest.&lt;/p&gt;
&lt;h2 id=&#34;installation&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#installation&#34;&gt;
        #
    &lt;/a&gt;
    Installation
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;First you will go to the ImageJ documentation website and navigate &lt;code&gt;Explore&lt;/code&gt; → &lt;code&gt;Software&lt;/code&gt; → &lt;code&gt;Fiji&lt;/code&gt;. Or just follow this link: &lt;a href=&#34;https://imagej.net/software/fiji/&#34;&gt;https://imagej.net/software/fiji/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Once here you will choose the appropriate download depending on your operating system (OS). This tutorial will assume the usage of window OS but the process should be very similar for Mac devices.&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/downloads.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;Create a new folder on your desktop to store Fiji and all of your work for this class. The file you have just downloaded will come in a .zip file, extract the files and you can delete the .zip afterwards. Then navigate into the Fiji.app folder and open the ImageJ-win64 (if you’re on windows) application. You will be greeted with some additional documentation windows and a prompt to update the client, please update your ImageJ to the latest version. If you did not receive an update message navigate to &lt;code&gt;Help&lt;/code&gt; →  &lt;code&gt;Update&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Navigate to the ImageJ Updater (&lt;code&gt;Help&lt;/code&gt; →  &lt;code&gt;Update&lt;/code&gt;) as just specified and hit “Manage Update Sites” scroll and find the plugin called “Bio-Formats”, check the box, apply update, and restart ImageJ. Bio-Formats is a plugin which will allow us to import images of various file formats outputted by microscopes. Some common examples of these file types you may come across include TIFF/OME-TIFF, CZI, ND2, etc. Check the Bio-Formats documentation for a complete list, these are just some of the most popular.&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bioformats.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;This completes the software setup section of this tutorial, now we can start working with some data.&lt;/p&gt;
&lt;h2 id=&#34;some-basics&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#some-basics&#34;&gt;
        #
    &lt;/a&gt;
    Some Basics
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;Fiji comes with many preset data samples that we can use to test out some of the features of this software (&lt;code&gt;File&lt;/code&gt; →  &lt;code&gt;Open Samples&lt;/code&gt;). By the end of this tutorial you will learn how to do some basic preprocessing and morphological analysis on cellular imaging data in Fiji.&lt;/p&gt;
&lt;p&gt;Now we will go over some of the basics about loading data into Fiji. It is important to understand how image files are loaded in and how you can manipulate these files effectively.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lookup Tables (LUT)&lt;/strong&gt; are how we will go about applying color to a given image, find the “LUT” tab on Fiji and you will see a wide selection of choices to be used in many applications. For the most part we are only interested in solid colors such as red, green, and blue. It is also possible to create a custom LUT but that is more advanced, for now just know that it is something you are able to do. The term lookup table is used here because we are looking up values within a table of values which maps one color in your original image to another color defined in the table.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/LUT.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Stacks&lt;/strong&gt; are used to retain multiple spatially or temporally related images taken by the microscope. Below are some examples of what each of these may look like using the “Mitosis {5D Stack}” sample from the default Fiji data shown below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/mitosis.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;An example of a normal stack (Z-stack) would be the MRI sample where we have the XY axes and then we can slide through the Z-axis of the MRI scan.&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Composite Images&lt;/strong&gt; are mostly seen in florescence microscopy images and allows us to combine multiple color channels and view various cellular features at once. An example of this would be the “florescent cells” sample. Here we have three channels in RGB colors, the red (Texas Red X-Phalloidin) shows F-Actin, green (Goat anti-mouse IgG) shows tubulin, and blue (DAPI) shows nuclei. In practice we will name the images based on the stain and cellular feature so it’s important to know them well.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/rgbcells.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;How can we split multi-channel stack/composite images? It is often the case that we want to take a composite image and split it in order to preprocess different attributes of the image. In order to split an image click &lt;code&gt;Images&lt;/code&gt; → &lt;code&gt;Color&lt;/code&gt; → &lt;code&gt;Split Channels&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;filters&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#filters&#34;&gt;
        #
    &lt;/a&gt;
    Filters
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;In this section we will cover some basic filtering steps that can help reduce noise and obstructions in imaging data, this is typically the first step of a larger image processing pipeline.&lt;/p&gt;
&lt;p&gt;Max/Min/Median filtering is a technique where we take a patch of the image (kernel) and compute the max/min/median of every pixel color value in that patch and then replace the center value with the max/min/median value. The median filter has the effect that outlier values (very dark or light colors)  will get filtered out, this reduces noise and retains edges better than the averaging (mean) filter because we are not computing a new color value but using an existing one. We can see the difference in how edges are conserved using the boat sample with radius 10.0 Left=Median, Right=Mean.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/medianfilter.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 1&lt;/strong&gt; Try applying median filtering with varying radius to an image of your choice&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 2&lt;/strong&gt; Try applying other filters to an image of your choice (min, max, convolve, variance), what kind of effects do they have?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; How do we select the radius when applying filters to images? This depends on what your objectives are and the type of image you are analyzing (feature size, noise, etc.), typically we start small and determine a radius size experimentally.&lt;/p&gt;
&lt;p&gt;Typically a pixel within an image is represented by three numerical values which tell us the ratio of red (R), green (G), and blue (B) that make up a certain color. So what exactly does it mean to take the maximum or minimum of these values? In the case of Fiji we are actually isolating each channel, applying the filter, then combining it again. Cool, right? In later tutorials we will cover more complicated filtering techniques which make use of mathematical transformations which can be used for better denoising and feature extraction.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/colors.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;segmentation&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#segmentation&#34;&gt;
        #
    &lt;/a&gt;
    Segmentation
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;We will now cover some basic image segmentation, specifically we will look at background removal using the Fiji functions as well as different types of thresholding. First you must make sure that your image is grayscale (&lt;code&gt;Image&lt;/code&gt; → &lt;code&gt;Type&lt;/code&gt; → &lt;code&gt;8-bit&lt;/code&gt;). The background subtraction function within Fiji works better if you have well defined edges in your image so it might help to play around with the brightness and contrast settings (&lt;code&gt;Image&lt;/code&gt; → &lt;code&gt;Adjust&lt;/code&gt; → &lt;code&gt;Brightness/Contrast&lt;/code&gt;) until your image’s edges look a little better. Some images already have plain backgrounds so removal is not necessary.&lt;/p&gt;
&lt;p&gt;Lets take for example the Blobs sample image. We can see that there is a textured background which can interfere with our analyses, in order to remove this we will have to use the rolling ball background subtraction algorithm. To apply this, select &lt;code&gt;Process&lt;/code&gt; → &lt;code&gt;Subtract Background&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt; Using this algorithm may cause image artifacts or unwanted effects so proceed with caution, for our case in purposes we can disregard any artifacting.&lt;/p&gt;
&lt;p&gt;After the background is removed or mitigated we can start trying to segment our features of interest using thresholding. Within Fiji we have many different options for thresholding which can be accessed through the (&lt;code&gt;Image&lt;/code&gt; → &lt;code&gt;Adjust&lt;/code&gt;) menu. For the time being we won’t concern ourselves with how thresholding works and that will be left for a more in depth future tutorial. The standard threshold option will allow you to manually analyze an intensity histogram which allows us to separate the image based on feature and background color. The problem with this approach is that it requires quite a bit of human thinking and reproducing the result might be difficult.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/manual_thresh.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;To address this problem we can use the &lt;code&gt;Auto Threshold&lt;/code&gt; option which can make this selection for us based on some algorithm. In total there are 17 of these that are available in Fiji and we have the option of running all of them at once and then choosing the best one as shown below.&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/autothresh_2.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;Note that the output of the thresholding is a black and white image, this is called a binary image and each pixel is one of two color values either black or white. These binary images allow us to perform some additional modifications to our image. Take a look under (&lt;code&gt;Process&lt;/code&gt; → &lt;code&gt;Binary&lt;/code&gt;), these are options available for binary image manipulation. Erosion and dilation can be used to decrease or increase the outer layer from features in the image (black attributes). In future tutorials we will go over these manipulations in more detail. Once we have a segmentation that looks good we are ready to move onto the analysis of the features.&lt;/p&gt;
&lt;h2 id=&#34;analysis&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#analysis&#34;&gt;
        #
    &lt;/a&gt;
    Analysis
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;Once we have our binary image of our blobs we can run certain analyses on these, namely all of the options listed under (&lt;code&gt;Analyze&lt;/code&gt; → &lt;code&gt;Set Measurements&lt;/code&gt;). Within this menu you will be able to select/deselect measurements depending one what kind of analyses you’re doing.&lt;/p&gt;
&lt;p&gt;Pay close attention to the option at the bottom “Redirect to:” and recall that the image we are analyzing is binary, meaning that all intensity measurements such as min/max gray values make no sense at all. This redirect option will allow you to use the binary image as a mask and report measurements from another, non-binary, image. So this is when we will use the image of the blobs we duplicated earlier, we will use the binary segmentation image we created to measure features in our original image.&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/set_measurements.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;Now that we have set our desired measurements we can select the (&lt;code&gt;Analyze&lt;/code&gt; → &lt;code&gt;Analyze Particles&lt;/code&gt;) option and run the analysis. Right before analyzing the blobs you must specify two attributes, namely the expected size range and circularity of your features. These options will allow you to filter out super small dot-like artifacts that shouldn’t be counted or non-circular objects. Under “Show:” you want to select overlay masks in order to display the results on the binary image, this doesn’t affect the analysis in any way just the way the output data is displayed.&lt;/p&gt;
&lt;p&gt;Now the output of the &lt;code&gt;Analyze Particles&lt;/code&gt; function should be a table where the rows correspond to different features in your image and columns correspond to the measurements you selected in the &lt;code&gt;Set Measurements&lt;/code&gt; settings.&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/segmentation.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;A common error that arises in the analysis stage is that the image is inverted so we end up analyzing the background on accident. It can get a bit confusing especially when messing with the LUTs. It is important to note that the setting (&lt;code&gt;Edit&lt;/code&gt; → &lt;code&gt;Invert&lt;/code&gt;) is different from inverting the LUT, and this is the most common cause of error in the Analyze Particles function. Make sure that when you analyze the particles that the output table has a reasonable number of entries and that the correct areas are being overlay masked in the binary image.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/error.png&#34; alt=&#34;Sunset&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;some-final-remarks&#34; &gt;
&lt;div&gt;
    &lt;a href=&#34;#some-final-remarks&#34;&gt;
        #
    &lt;/a&gt;
    Some Final Remarks
&lt;/div&gt;
&lt;/h2&gt;
&lt;p&gt;A key feature that we haven’t mentioned in this tutorial is Fiji’s potential for analyzing 3D cell images. Fiji has many options as you may have noticed in the menus for 3D images and it is actually a similar process. There are many resources I will provide links to dealing with these types of images but for our case and purposes we are only concerned with 2D imaging so you are not required to learn the 3D image analysis.&lt;/p&gt;
&lt;p&gt;This pretty much concludes the Fiji basic analysis tutorial and there is still a lot for you to explore within Fiji. There are also a lot of features which Fiji lacks and in future tutorials we will be talking about other image analysis programs that take a different approach to solving this problem.&lt;/p&gt;
&lt;div style=&#34;height: 20px;&#34;&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Relevant Resources&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hallvaaw/awesome-biological-image-analysis&#34;&gt;Awesome Biological Image Analysis&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
