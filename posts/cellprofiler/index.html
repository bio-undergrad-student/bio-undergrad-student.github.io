<!DOCTYPE html>


<html lang="en-us" data-theme="">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>High-Throughput Cell Image Analysis With CellProfiler &#x1f4a8; - Tutorials on Image Analysis Algorithms</title>

<meta name="description" content="In this tutorial you will be introduced to the morphological profiling tool CellProfiler and some post-processing approaches.">





<link rel="icon" type="image/x-icon" href="https://bio-undergrad-student.github.io/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://bio-undergrad-student.github.io/favicon.png">








    



<style>
  body {
    visibility: hidden;
    opacity: 0;
  }
</style>

<noscript>
  <style>
    body {
      visibility: visible;
      opacity: 1;
    }
  </style>
</noscript>




    





    
    
        
    
    

    
        <link rel="stylesheet" href="/css/style.min.44f8240afd8df81b52565c4119ac5ae247776c77fc6d7ccf6e101a6c98abfa7a.css" integrity="sha256-RPgkCv2N&#43;BtSVlxBGaxa4kd3bHf8bXzPbhAabJir&#43;no=">
    





    





    
    
        
    
    

    
        <link rel="stylesheet" href="/css/style.min.c4c04b3ef88e3d619ad4c7ee5e03048422bc55c4fefdc1f07657c1133670aa22.css" integrity="sha256-xMBLPviOPWGa1MfuXgMEhCK8VcT&#43;/cHwdlfBEzZwqiI=">
    





    





    
    
        
    
    

    
        <link rel="stylesheet" href="/css/style.min.21c5d8fe0a79d623b0adc1ce4bd4f6dd2c05cd939c9aaaa966ba7186b1464f4d.css" integrity="sha256-IcXY/gp51iOwrcHOS9T23SwFzZOcmqqpZrpxhrFGT00=">
    












    

    





    
    
        
    
    

    
        <script src="/js/script.min.08f04d96386c73c9bf4d160333f8f448c05a6e01c06770542ee0e013954ce930.js" type="text/javascript" charset="utf-8" integrity="sha256-CPBNljhsc8m/TRYDM/j0SMBabgHAZ3BULuDgE5VM6TA="></script>
    



















    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header class="common-header">
            
                <div class="header-top">
    <div class="header-top-left">
        <h1 class="site-title noselect">
    <a href="/">Tutorials on Image Analysis Algorithms</a>
</h1>

        







    
        <div class="theme-switcher">
            <span class="inline-svg">

    


    
    
    
    
    

    <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-sun-high"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14.828 14.828a4 4 0 1 0 -5.656 -5.656a4 4 0 0 0 5.656 5.656z" /><path d="M6.343 17.657l-1.414 1.414" /><path d="M6.343 6.343l-1.414 -1.414" /><path d="M17.657 6.343l1.414 -1.414" /><path d="M17.657 17.657l1.414 1.414" /><path d="M4 12h-2" /><path d="M12 4v-2" /><path d="M20 12h2" /><path d="M12 20v2" /></svg>


</span>

        </div>
    

    <script>
        const STORAGE_KEY = 'user-color-scheme'
        const defaultTheme = "light"

        let currentTheme
        let switchButton
        let autoDefinedScheme = window.matchMedia('(prefers-color-scheme: dark)')

        function switchTheme(e) {
            currentTheme = (currentTheme === 'dark') ? 'light' : 'dark';
            if (localStorage) localStorage.setItem(STORAGE_KEY, currentTheme);
            document.documentElement.setAttribute('data-theme', currentTheme);
            changeGiscusTheme(currentTheme);
            document.body.dispatchEvent(new CustomEvent(currentTheme + "-theme-set"));
        }

        const autoChangeScheme = e => {
            currentTheme = e.matches ? 'dark' : 'light'
            document.documentElement.setAttribute('data-theme', currentTheme);
            changeGiscusTheme(currentTheme);
            document.body.dispatchEvent(new CustomEvent(currentTheme + "-theme-set"));
        }

        document.addEventListener('DOMContentLoaded', function () {
            switchButton = document.querySelector('.theme-switcher')
            currentTheme = detectCurrentScheme()

            if (currentTheme === 'auto') {
                autoChangeScheme(autoDefinedScheme);
                autoDefinedScheme.addListener(autoChangeScheme);
            } else {
                document.documentElement.setAttribute('data-theme', currentTheme)
            }

            if (switchButton) {
                switchButton.addEventListener('click', switchTheme, false)
            }

            showContent();
        })

        function detectCurrentScheme() {
            if (localStorage !== null && localStorage.getItem(STORAGE_KEY)) {
                return localStorage.getItem(STORAGE_KEY)
            }
            if (defaultTheme) {
                return defaultTheme
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function showContent() {
            document.body.style.visibility = 'visible';
            document.body.style.opacity = 1;
        }

        function changeGiscusTheme (theme) {
            function sendMessage(message) {
              const iframe = document.querySelector('iframe.giscus-frame');
              if (!iframe) return;
              iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
            }

            sendMessage({
              setConfig: {
                theme: theme
              }
            });
        }
    </script>


        <ul class="social-icons noselect">







    <li>
            <a href="/index.xml" title="RSS" rel="me">
            <span class="inline-svg">

    


    
    
    
    
    

    <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" /><path d="M4 4a16 16 0 0 1 16 16" /><path d="M4 11a9 9 0 0 1 9 9" /></svg>


</span>

            </a>
        </li>
    

</ul>

    </div>
    <div class="header-top-right">

    </div>
</div>


    <nav class="noselect">
        
        
        <a class="" href="https://bio-undergrad-student.github.io/" title="">Home</a>
        
        <a class="" href="https://bio-undergrad-student.github.io/about/" title="">About</a>
        
        <a class="" href="https://bio-undergrad-student.github.io/posts/" title="">Archive</a>
        
    </nav>



<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>





            
        </header>
        <main id="main" tabindex="-1">
            
    

    <article class="post h-entry">
        <div class="post-header">
            <header>
                <h1 class="p-name post-title">High-Throughput Cell Image Analysis With CellProfiler &#x1f4a8;</h1>
                

            </header>
            



<div class="post-info noselect">
    

    <a class="post-hidden-url u-url" href="/posts/cellprofiler/">/posts/cellprofiler/</a>
    <a href="https://bio-undergrad-student.github.io/" class="p-name p-author post-hidden-author h-card" rel="me"></a>


    <div class="post-taxonomies">
        
        
        
    </div>
</div>

        </div>
        

  
  




  
  
  
  <details class="toc noselect">
    <summary>Table of Contents</summary>
    <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#background">Background</a></li>
    <li><a href="#installation-and-setup">Installation and Setup</a></li>
    <li><a href="#examples">Examples</a></li>
    <li><a href="#morphological-profiling-at-scale">Morphological Profiling at Scale</a>
      <ul>
        <li><a href="#pipeline-design">Pipeline Design</a></li>
        <li><a href="#testing-and-debugging">Testing and Debugging</a></li>
      </ul>
    </li>
    <li><a href="#post-processing">Post-Processing</a>
      <ul>
        <li><a href="#more-on-the-cellprofiler-output">More On the CellProfiler Output</a></li>
        <li><a href="#pycytominer-features">PyCytominer Features</a></li>
      </ul>
    </li>
    <li><a href="#final-remarks">Final Remarks</a></li>
    <li><a href="#appendix-feature-normalization-techniques">Appendix: Feature Normalization Techniques</a></li>
  </ul>
</nav></div>
  </details>
  



<script>
  var toc = document.querySelector(".toc");
  if (toc) {
    toc.addEventListener("click", function () {
      if (event.target.tagName !== "A") {
        event.preventDefault();
        if (this.open) {
          this.open = false;
          this.classList.remove("expanded");
        } else {
          this.open = true;
          this.classList.add("expanded");
        }
      }
    });
  }
</script>

        <div class="content e-content">
            <p>In this tutorial you will be introduced to the morphological profiling tool CellProfiler and some post-processing approaches.</p>
<h2 id="background" >
<div>
    <a href="#background">
        #
    </a>
    Background
</div>
</h2>
<p>There are many cases when we want to analyze thousands of cellular images such as when we do a large drug or CRISPR screen. Quantifying the effects that many drugs or gene perturbations has on cells can be challenging, this is why we use software such as Fiji. However, when we are screening thousands of drugs, we cannot analyze the resulting images manually as we did in project 1, it would take way too long. This is the same realization that Anne Carpenter had when she created the vision for CellProfiler.</p>
<div style="height: 20px;"></div>


<p><img src="/images/cell.jpeg" alt="Sunset"></p>
<div style="height: 20px;"></div>


<p>CellProfiler was first released by scientists at the Whitehead Institute for Biomedical Research in 2006,  it was originally written in the MATLAB programming language but was eventually re-implemented in Python. The main purpose of CellProfiler was to analyze image data from high-content screening and make thousands of measurements at the cellular level. The CellProfiler philosophy is ‘measure everything, ask questions later’ which can be very beneficial when working with lots of data. Much like Fiji, CellProfiler supports the Bio-Formats library as well as many of the same image adjustments. Additionally it supports more sophisticated classification using deep learning and provides dedicated preprocessing modules.</p>
<div style="height: 20px;"></div>


<p><img src="/images/pipeline.png" alt="Sunset"></p>
<h2 id="installation-and-setup" >
<div>
    <a href="#installation-and-setup">
        #
    </a>
    Installation and Setup
</div>
</h2>
<p>On Windows and Mac operating systems the CellProfiler is very simple, download the installer using the following link <a href="https://cellprofiler.org/releases">CellProfiler</a> and install. If you’re on a device running Linux it’s going to be a little more involved using a Conda environment follow this link to learn more <a href="https://github.com/CellProfiler/CellProfiler/wiki/Source-installation-(Linux)">Linux Installation Instructions</a>.</p>
<p>Once CellProfiler is up and running, you are first met with the a very plain user interface similar to Fiji. We will run through two examples using some of the default data, head over to the this link <a href="https://cellprofiler.org/examples">CellProfiler Example Data</a> and download the files required for the fruit fly cells and the object tracking.</p>
<h2 id="examples" >
<div>
    <a href="#examples">
        #
    </a>
    Examples
</div>
</h2>
<p>We are now going to go over the two examples you just downloaded, after familiarizing yourself with simple functions and pipelines we will go into how you can make your own. Inside each example folder you will be met with two key pieces of information, first a CellProfiler pipeline file <code>.cppipe</code> and then the data itself.</p>
<p><strong>Setting Default Output</strong>
When running pipelines you can automatically save all of the data from an analysis, when dealing with high throughput experiments this data can be become very large. To ensure you are saving all of your data in the correct place check <code>Output Settings</code> on the bottom left and make sure that you select a convenient location to save all of the outputs.</p>
<p><strong>Automated Image Analysis Using Pipelines</strong></p>
<p>Now that you have the set the output we are ready to analyze some imaging data. There are two primary steps when doing an analysis, loading the pipeline file and loading the data. Later we will go into more detail on how you can develop your own pipelines or where you can find more.</p>
<p>Loading Pipeline: To load the pipeline into your workspace navigate to <code>File</code> -&gt; <code>Import Pipeline</code> -&gt; <code>From File</code> and find the .cppipe file in the folder we downloaded.</p>
<p>Loading Data: The pipeline will load all of the tasks or analyses we are doing on the images, not the images themselves. So now you want to import the images we will use for this analysis by dragging and dropping them in the main menu from the folder we downloaded earlier.</p>
<div style="height: 20px;"></div>


<blockquote>
<p><strong>Exercise 1</strong> Now try it yourself, use the fruit fly pipeline and data we download earlier and run the analysis on CellProfiler</p>
</blockquote>
<blockquote>
<p><strong>Exercise 2</strong> Let’s do another example, this time with time-lapse data for object tracking.</p>
</blockquote>
<div style="height: 20px;"></div>


<p>These two examples show how powerful CellProfiler is for analyzing many images at once. But as you may have noticed, it can take a while to run these pipelines. If you are interested in learning more about what exactly the measurements mean you can take a look at this resource <a href="https://cellprofiler-manual.s3.amazonaws.com/CellProfiler-3.0.0/modules/measurement.html#measureobjectintensitydistribution">From CellProfiler Documentation</a>.</p>
<div style="height: 20px;"></div>


<p><img src="/images/measurements.png" alt="Sunset"></p>
<div style="height: 20px;"></div>


<p>If you don’t have the time to look at all of the measurements, here is a small preview using <code>MeasureObjectIntensityDistribution</code>, the diagram above describes exactly what is being measured by this module. It is remarkable how CellProfiler can make this many measurements all at once. However, it also makes one think whether or not all of these measurements are necessary. We will speak on this problem in future tutorials.</p>
<h2 id="morphological-profiling-at-scale" >
<div>
    <a href="#morphological-profiling-at-scale">
        #
    </a>
    Morphological Profiling at Scale
</div>
</h2>
<p>Notice that unlike Fiji, we can’t really analyze a single image at our leisure, we must create a pipeline in order to analyze an image. For this reason CellProfiler is typically preferred when analyzing large datasets where we want to apply the same kind of analysis to all of our data. In cases where the dataset is small or we want to apply different kinds of analyses to individual images in a dataset, Fiji might be easier to use.</p>
<h3 id="pipeline-design" >
<div>
    <a href="#pipeline-design">
        ##
    </a>
    Pipeline Design
</div>
</h3>
<p>It is rare that the type of analysis we want to do on real lab data will be readily available online. For this reason many researchers working on imaging will develop their own CellProfiler pipelines to fit the specific study they are working on. <a href="https://cellprofiler.org/published-pipelines">Here</a> is a neat resource, an official list of published pipelines that have been used in scientific studies in a diverse range of application areas. Unlike the examples from earlier, these downloads don’t come with the data from the study but it is still a useful in learning which modules are useful for which studies.</p>
<p>Next we will familiarize ourselves with some of the classes of modules that are offered by CellProfiler.</p>
<p><strong>File Processing</strong></p>
<p>These modules are used either when you want to load data for usage or export data and save it to your files or a database.</p>
<p><strong>Image Processing</strong></p>
<p>The image processing modules are, for the most part, very similar to those found on the ImageJ/Fiji Image/Process tabs. Put simply, these are all modules that apply to an image as a whole. Upon adding one of these modules you will be met with additional options to including input, algorithm, output, and some miscellaneous file settings.</p>
<p><strong>Object Processing</strong></p>
<p>In CellProfiler we also have modules for individual objects within an image, this means that these apply to each object (cells, nuclei, organelles, etc.). These modules are used to do the actual identification/classification of objects or adjusting the size or attributes of those objects e.g. masking certain objects. To create objects, use the following functions&hellip;</p>
<p><code>IdentifyPrimaryObjects</code> Detects the smallest objects, such as nuclei.</p>
<p><code>IdentifySecondaryObjects</code> Expands primary objects to identify regions like whole cells.</p>
<p><code>IdentifyTertiaryObjects</code> Identifies regions by subtracting one object from another (e.g., cytoplasm = cell - nucleus).</p>
<p><img src="/images/egg2.jpg" alt="Sunset"></p>
<p><strong>Measurement</strong></p>
<p>These modules will take measurements of your objects, this is very similar to the <code>Analyze</code> tab in ImageJ/Fiji. If you remember the examples from earlier, the measurements that we made on the fruit fly cell images were very detailed. There are many options for the types of measurements being made, there are some that are taken in reference to the entire image and those which will correspond to individual objects.</p>
<p><strong>Data Tools</strong></p>
<p>The data tools in CellProfiler refer to any type of data visualization or computation of statistics both of which we also got to see in the examples. For the fruit fly example we had a bar graph displaying the various object information like counts and size.</p>
<h3 id="testing-and-debugging" >
<div>
    <a href="#testing-and-debugging">
        ##
    </a>
    Testing and Debugging
</div>
</h3>
<p>Before implementing your own pipeline it is important that you are aware of the <code>Test Mode</code> offered by CellProfiler. This feature will be your best friend when developing pipelines as it is unlikely that you will get them to work perfectly the first time. The main function of the test mode is to run your pipeline on some test data and get a preview of the analysis results without saving everything. By using test mode you can tweak the module specifications ever so slightly and quickly see the effect on the result.</p>
<p>If you have programmed before in languages such as Java, C, or C++ you may be familiar with the Java debugger (JDB) or GNU Debugger (GDB). These are powerful tools that allow you to run code line by line with the purpose of helping the programmer find the line where errors are arising. CellProfiler’s test mode will allow you to run your pipeline in a very similar way, i.e. instead of code we will run individual modules from the pipeline one by one to make sure we are getting a correct output at every stage. This was never a problem in Fiji as we are already running commands independently but when our objective becomes to create a long string of commands i.e. a pipeline then it becomes a little harder determine where problems are arising.</p>
<p>CellProfiler’s test mode teaches us a very valuable lesson applicable to any type of program development, and that is how to break down your code to fix bugs. If you are ever stuck and your code is not running, the exact same approach should be taken.</p>
<div style="height: 20px;"></div>


<blockquote>
<p><strong>Exercise 3</strong> Implement a simple pipeline in CellProfiler to identify cell count, area, shape properties in the images you selected from project 1.</p>
</blockquote>
<div style="height: 20px;"></div>


<p><strong>Looking Back</strong></p>
<p>Take a look at the input and output of a pipeline for the JUMP-CP data. Some of the pipeline files can be found <a href="https://github.com/broadinstitute/imaging-platform-pipelines/tree/master/JUMP_production">HERE</a>, and another useful exercise is to go back to the JUMP-CP Quilt database found <a href="https://open.quiltdata.com/b/cellpainting-gallery/tree/">HERE</a> and take a look around at the <code>Analysis</code> folders, these folders contain the CellProfiler outputs for each and every image in the database. It is incredible to think about the scale and size of this database and how many CSV files there are in this AWS bucket. Manually analyzing these images without CellProfiler would be impossible so this would be a perfect example of when a software like this is game-changing.</p>
<p>There are still many problems in cellular biology where there is no efficient computational workflow that exists for large datasets. This example shows the applicability and benefits of not only knowing how to use existing software but being able to engineer your own.</p>
<h2 id="post-processing" >
<div>
    <a href="#post-processing">
        #
    </a>
    Post-Processing
</div>
</h2>
<p>While there are a lot of tasks that CellProfiler can help on regarding morphological profiling tasks, it cannot analyze any of the profiling data or prepare the data for analysis. There is a category of tools that can help with this problem, we will go over one of these tools called Cytominer which serves the purpose of cleaning and preparing the data to make biological conclusions. The original version of Cytominer was implemented in R but now we have a Python adaptation called PyCytominer which is what we will use.</p>
<h3 id="more-on-the-cellprofiler-output" >
<div>
    <a href="#more-on-the-cellprofiler-output">
        ##
    </a>
    More On the CellProfiler Output
</div>
</h3>
<p>The CellProfiler output is a $n \times m$ matrix of values corresponding to a specific well on a plate from an experiment. Each of the $n$ rows of the matrix represent the cells found within the well, for each cell we also have $m$ features which can be used to describe those cells.</p>
<div style="height: 20px;"></div>


<p><img src="/images/matrix.png" alt="Sunset"></p>
<p>It is important to note that CellProfiler takes a lot of measurements, sometimes in the thousands. Measurements can be highly correlated meaning they depend on each other or can have significantly different distributions making comparison difficult. Having additional highly correlated features that do not contribute to the data that much can complicate further analysis of the results so we’d like to have a way to address these. These problems along with many others can be addressed using the PyCytominer Python package.</p>
<h3 id="pycytominer-features" >
<div>
    <a href="#pycytominer-features">
        ##
    </a>
    PyCytominer Features
</div>
</h3>
<p><strong>Aggregation</strong>
As the name suggest, this module seeks to aggregate profiles and in particular several single-cell profiles into individual well profiles. This means that means that your new profile/matrix will have rows corresponding to wells as opposed to cells. The primary way to accomplish this is to use the mean or median. The function will summarize all of the cells corresponding to a well using one of these statistics, the default method is the median because it is less sensitive to outliers. Typically you would want to use this module when you have too much data and want to simplify the analysis. Do not use this if you are interested in single cell insights or outliers.</p>
<div style="height: 20px;"></div>


<p><img src="/images/aggregation.png" alt="Sunset"></p>
<div style="height: 20px;"></div>


<p><strong>Annotation</strong></p>
<p>This module does not affect the data in any way but it instead helps incorporate the plate metadata into the profiles given a platemap. A platemap is a table that assigns each well in a plate an associated set of metadata values including experiment information, source, plate, etc.</p>
<div style="height: 20px;"></div>


<p><strong>Normalization</strong></p>
<p>When we say we want to normalize the data this typically means to get every feature on the same scale or have consistent distributions. This is useful because it allows us to analyze all of the measurements assuming they have the same range of values (helpful for many machine learning algorithms). Sometimes normalization can help remediate batch effect, the technical variation arising in data if it comes from several different experiments.</p>
<p>From the source code we can see there are four different methods for normalization: avail_methods = <code>standardize</code>, <code>robustize</code>, <code>mad_robustize</code>, <code>spherize</code> It is not clear what these methods are doing based on the names or when they should be used. I will provide a short appendix at the end which will explain each one of these in a little more detail.</p>
<div style="height: 20px;"></div>


<p><img src="/images/normalization.png" alt="Sunset"></p>
<div style="height: 20px;"></div>


<p><strong>Feature Selection</strong></p>
<p>This is the process of removing any non-informative features/measurements, this process is typically done using a variety of factors. The features that will be removed are those with low variance, are made up of almost all NaN values, are known to not be useful based on domain knowledge, any outliers, and features that are highly correlated with another. This procedure allows us to reduce the amount of data which greatly simplifies any type of analysis.</p>
<div style="height: 20px;"></div>


<p><img src="/images/features.png" alt="Sunset"></p>
<div style="height: 20px;"></div>


<p><strong>Consensus</strong></p>
<p>This module can be used when you have multiple replicates e.g. if you have multiple wells with the same perturbation/condition. The module will combine several replicate profiles corresponding to a user-provided label and create a consensus profile. The options here are either plate-level or well-level consensus using median values by default.</p>
<p><img src="/images/consensus.png" alt="Sunset"></p>
<p>Typically you would use a combination of these different modules to process your data before drawing any type of conclusions. There are more steps you could take in terms of post processing in order to make your data even more suitable but we will go over those in later tutorials. While it is common for PyCytominer to be used for data coming from large scale cell painting experiments, procedures such as feature selection and normalization are still widely used all kinds of machine learning tasks.</p>
<h2 id="final-remarks" >
<div>
    <a href="#final-remarks">
        #
    </a>
    Final Remarks
</div>
</h2>
<p>CellProfiler is a very powerful tool to do morphological profiling in cell imaging data. It is important to know when to use CellProfiler as opposed to other tools like Fiji/ImageJ so that you do not spend any extra effort. Additionally, post-processing is an important step in the analysis pipeline which is often overlooked, make sure to understand the PyCytominer package and when it should be used. Down below I have left some additional project ideas in order to familiarize yourself with these concepts further.</p>
<div style="height: 20px;"></div>


<p><strong>Additional Project Ideas</strong></p>
<div style="height: 20px;"></div>


<blockquote>
<p><strong>Project 1</strong> Run cellprofiler on a subset of the JUMP-CP data using the JUMP-CP provided pipelines.</p>
</blockquote>
<blockquote>
<p><strong>Project 2</strong> Within the Quilt database for source 1 morphological profiles are provided for each and every well in their experiment, these come in the form of <code>.parquet</code> files. Do some research on the file format and how to work with it, then use PyCytominer to process these into well-level profiles. Do this for about 10 wells.</p>
</blockquote>
<blockquote>
<p><strong>Project 3 (Advanced)</strong> Visualize the profiles from project 2 using different dimensionality reduction techniques such as different types of PCA, t-SNE, or UMAP. What do these plots represent? What does it mean if certain points are clustering, or are they all separate?</p>
</blockquote>
<div style="height: 20px;"></div>


<p><strong>Resources</strong></p>
<p><a href="https://cellprofiler-manual.s3.amazonaws.com/CellProfiler-4.2.8/index.html">CellProfiler Documentation</a></p>
<div style="height: 20px;"></div>



<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/KDQFUmDJ3nY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<div style="height: 20px;"></div>


<p><strong>References</strong></p>
<p>[1] D. R. Stirling, M. J. Swain-Bowden, A. M. Lucas, A. E. Carpenter, B. A. Cimini, and A. Goodman, “CellProfiler 4: improvements in speed, utility and usability,” BMC Bioinformatics, vol. 22, no. 1, Sep. 2021, doi: <a href="https://doi.org/10.1186/s12859-021-04344-9">https://doi.org/10.1186/s12859-021-04344-9</a>.</p>
<p>[2] E. Serrano et al., “Reproducible image-based profiling with Pycytominer,” <a href="http://arxiv.org/">arXiv.org</a>, 2023. <a href="https://arxiv.org/abs/2311.13417">https://arxiv.org/abs/2311.13417</a>.</p>
<h2 id="appendix-feature-normalization-techniques" >
<div>
    <a href="#appendix-feature-normalization-techniques">
        #
    </a>
    Appendix: Feature Normalization Techniques
</div>
</h2>
<p>For context the names of avail_methods are made up by the creators of PyCytominer. Here is a list of the normalization functions along with descriptions and cases when each of them should be used.</p>
<div style="height: 20px;"></div>


<p><strong>Standardize</strong> - Z-Score Scaler</p>
<p>$$
X_{scaled} = \frac{X-\mu}{\sigma}
$$</p>
<p><strong>Robustize</strong> - Robust normalization scaled by interquartile range</p>
<p>$$
X_{scaled} = \frac{(X-median)}{IQR}
$$</p>
<p>IQR is calculated as the difference between the 75th percentile (Q3) and the 25th percentile (Q1)</p>
<div style="height: 20px;"></div>


<p><strong>Robustize MAD</strong> - Robust normalization scaled by mean absolute deviation</p>
<p>$$
MAD = \frac{1}{n}\sum_{i=1}^{n} |x_i-\mu|
$$</p>
<p>$$
X_{scaled} = \frac{(X-median)}{MAD}
$$</p>
<blockquote>
<p><strong>Remark</strong> These are called robust normalization techniques because they make use of robust statistics such as the median and mean absolute deviation. For a statistic to be robust means that it is less sensitive to outliers or non-Gaussian data, these are extreme values (very large or very small) that may influence the mean value. So now a good question is, when should robust normalization be used and, when it is used, when to scale by IQR vs MAD?</p>
</blockquote>
<div style="height: 20px;"></div>


<p><strong>Spherize</strong> - Sphering (Whitening) Transformation</p>
<p>This method a bit different than all that were mentioned, it is a linear transformation that aims to decorrelate the features and normalize their variance to 1. If you have heard of principle component analysis (PCA) then this transformation may look a little familiar, the following description will require some knowledge of linear algebra but I will try my best to explain what is happening at each step.</p>
<p>The following procedure is known as ZCA-Cor (Zero-Phase Component Analysis w.r.t Correlation) and is the default option in the PyCytominer Spherize method.</p>
<p>Standardize Data: The first step is to make sure our data has mean zero for the covariance matrix computation. At the same time we can also ensure that our data has unit variance, this will suffice for the ZCA-Cor requirements.</p>
<p>$$
X_{S} = \frac{X - \mu}{\sigma}
$$</p>
<p>Covariance Matrix: The covariance matrix formula $\Sigma$ and its eigendecomposition.</p>
<p>$$
\Sigma = \frac{1}{n-1} X_{S}^TX_{S}
$$</p>
<p>$$
\Sigma = Q \Lambda Q^T
$$</p>
<p>Compute Sphering Transform: We will take an alternative approach to compute the transform, this is the form for the PCA-Cor sphering transform. The Kessy et al. paper [3] tells us that the ZCA-Cor can be computed in the same way as PCA-Cor but simply adding an additional rotation to return to the original coordinates. To compute the sphering transform $W$ we can use the following&hellip;</p>
<p>$$
W = \Lambda^{-1/2}Q^{T}
$$</p>
<p>First we will take the singular value decomposition (SVD) of our data $X_S$.</p>
<p>$$
X_{S} = USV^{T}
$$</p>
<p>Substituting the SVD in place of $X_S$.</p>
<p>$$
\Sigma = \frac{1}{n-1} X_{S}^TX_{S} = \frac{1}{n-1} VSU^T USV^T =\frac{1}{n-1} VS^2V^T
$$</p>
<p>This tells us that we can get the inverse square root of lambda from the following relationships&hellip;</p>
<p>$$
Q = V
$$</p>
<p>$$
\Lambda = \frac{1}{n-1} S^2 \implies \Lambda^{-1/2} = S^{-1} \sqrt{n-1}
$$</p>
<p>We now have the PCA-Cor sphering transform within the parenthesis and then an additional rotation $V$ to get the ZCA-Cor sphering transform.</p>
<p>$$
W = V(S^{-1}V^T\sqrt{n-1})
$$</p>
<p>Finally we can apply the transformation to our data.</p>
<p>$$
Z = WX_{S}
$$</p>
<p>Overall the sphering approach to normalization is a lot more involved than all of the others, but why should we bother? Sphering can be very useful depending on what kind of analysis you are doing, for example machine learning algorithms which use gradient-based optimization can benefit greatly from what it has to offer. Another reason why you might want to use sphering is because it can help with batch effect when combining several datasets from different experiments. We will go into greater depth on batch correction in the future. If you’re unsure of which normalization approach to use, you should experiment with different methods until you find the best for your use case.</p>
<div style="height: 20px;"></div>


<p>If you have any additional questions about the procedure discussed above please refer to the Kessy et al. paper [3] or the PyCytominer source code both referenced below.</p>
<div style="height: 20px;"></div>


<p><a href="https://github.com/cytomining/pycytominer">Source Code</a></p>
<p>[3] A. Kessy, A. Lewin, and K. Strimmer, “Optimal Whitening and Decorrelation,” The American Statistician, vol. 72, no. 4, pp. 309–314, Jan. 2018, doi: <a href="https://doi.org/10.1080/00031305.2016.1277159">https://doi.org/10.1080/00031305.2016.1277159</a>.
‌</p>
        </div>

    </article>

    
    

    
        
        
    

    

    
        









    

    

    

    

        </main>
        
            <footer class="common-footer noselect">
    
    

    <div class="common-footer-bottom">
        

        <div style="display: flex; align-items: center; gap:8px">
            ©  2025
            
        </div>
        <div style="display:flex;align-items: center">
            
            
            
            
            
            
        </div>
        <div>
            Powered by <a target="_blank" rel="noopener noreferrer" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" rel="noopener noreferrer" href="https://github.com/Junyi-99/hugo-theme-anubis2">Anubis2</a>.<br>
            

        </div>
    </div>

    <p class="h-card vcard">

    <a href=https://bio-undergrad-student.github.io/ class="p-name u-url url fn" rel="me"></a>

    

    
</p>

</footer>

        
    </div>
</body>
</html>
